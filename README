Pentru prima problema, am citit copacii 2 cate 2 si am verificat constant daca cel citit 'la mijloc' era special. Daca da, verificam daca se afla pe o pozitie para sau nu si ii comparam inaltimea cu H, respectiv h si ii adunam inaltimea la suman, numarandu-l. Calculam apoi si media inaltimilor, iar in cazul in care nu era niciun copac special dadeam tuturor lucrurilor pe care trebuia sa le aflu valoarea 0. Daca nu exista copaci pe pozitii pare sau impare dadeam lui H, respectiv h valoarea -1;

Pentru cea de a doua problema, am folosit mai multe functii care sa prelucreze cifrele unui numar. Am observat ca este mai usor sa folosesc un algoritm de palindrom decat de ordonare crescatoare a vectorului pentru a afla numarul mai mic, intrucat acesta era doar inversul celui mare fara cifra 0. Fiecare diferenta apare in vector si este apoi prelucrata, pana se repeta o valoare.

Pentru problema 3, am calculat ponderea fiecarei discipline. Ponderea reprezinta numarul maxim de credite pe care il mai poate obtine un elev la acea materie. Am ordonat descrescator ponderile, pentru a calcula numarul mminim de mariri necesare. Am calculat punctele de fiecare data cand faceam o marire si am comparat mereu punctajul curent cu cel minim necesar.

Pentru problema 4, am observat ca verificarea unui astfel de puzzle este usoara daca fac suma dimensiunilor grupurilor si o compar cu suma elementelor de pe fiecare linie/coloana. Am calculat numarul de elemente de 0 de pe fiecare linie/coloana si apoi am scazut acel numar din n/m. Am pastrat suma dimensiunilor grupurilor in 2 vectori separati pentru linii si coloane, fiecare element din fiecare coloana a vectorilor reprezentand suma grupurilor, indicele coloanei fiind indicele aferent liniei sau coloanei de verificat.